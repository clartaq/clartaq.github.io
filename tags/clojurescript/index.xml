<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojurescript on Yo-Dave</title>
    <link>https://yo-dave.com/tags/clojurescript/</link>
    <description>Recent content in Clojurescript on Yo-Dave</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2011-2018, David D. Clark. All rights reserved.</copyright>
    <lastBuildDate>Wed, 01 Aug 2018 15:56:32 -0400</lastBuildDate>
    
	<atom:link href="https://yo-dave.com/tags/clojurescript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Autosave Functionality in ClojureScript</title>
      <link>https://yo-dave.com/2018/08/01/autosave-functionality-in-clojurescript/</link>
      <pubDate>Wed, 01 Aug 2018 15:56:32 -0400</pubDate>
      
      <guid>https://yo-dave.com/2018/08/01/autosave-functionality-in-clojurescript/</guid>
      <description>Most programs provide an &amp;ldquo;Autosave&amp;rdquo; feature these days. The feature gives the user a chance to minimize the amount of work lost due to some unforeseen mishap, like a sudden power outage.
When I write a program in Clojure that requires such a feature, I have the entire Java library at my disposal. I usually create something based on a ScheduledExecutorService &amp;ndash; something that watches for a change in the document then allows a certain amount of user inactivity to pass before automatically saving the document.</description>
    </item>
    
    <item>
      <title>CWiki-Next</title>
      <link>https://yo-dave.com/2018/05/01/cwiki-next/</link>
      <pubDate>Tue, 01 May 2018 09:38:50 -0400</pubDate>
      
      <guid>https://yo-dave.com/2018/05/01/cwiki-next/</guid>
      <description>For the past few months, I&amp;rsquo;ve been beating my head against a brick wall. The problem was that I was trying to get an all-server-side wiki built using Clojure.
It actually works pretty well. I&amp;rsquo;ve been using it for personal information for months now. It works well except for one aspect, arguably the most important &amp;ndash; editing new or existing content is not that pleasant.
It&amp;rsquo;s all a variation of Markdown, which is nice.</description>
    </item>
    
    <item>
      <title>Using Anonymous Functions in the Clojure/Script Thrush Macro</title>
      <link>https://yo-dave.com/2018/04/15/using-anonymous-functions-in-the-clojure-script-thrush-macro/</link>
      <pubDate>Sun, 15 Apr 2018 11:48:25 -0400</pubDate>
      
      <guid>https://yo-dave.com/2018/04/15/using-anonymous-functions-in-the-clojure-script-thrush-macro/</guid>
      <description>The other day, I was putting together a sequence of operations to transform one piece of text into another form of that same text. The functions took a text argument, and the result was a slightly tweaked version. Put all those functions together to get the fully transformed result.
What could be more natural than to string those pieces of code together with one of Clojure&amp;rsquo;s threading macros: &amp;lsquo;-&amp;gt;&amp;rsquo; or &amp;lsquo;-&amp;gt;&amp;gt;.</description>
    </item>
    
    <item>
      <title>Clojure/Script has Ruined Me for Other Languages</title>
      <link>https://yo-dave.com/2016/10/17/clojure-script-has-ruined-me-for-other-languages/</link>
      <pubDate>Mon, 17 Oct 2016 10:57:40 +0000</pubDate>
      
      <guid>https://yo-dave.com/2016/10/17/clojure-script-has-ruined-me-for-other-languages/</guid>
      <description>The Elm language is often cited as an up-and-comer for web front end development. I was attracted to it largely because of the compiler&amp;rsquo;s friendly and extremely helpful error messages. It&amp;rsquo;s really attractive in many ways.
But when I started looking at examples, I often found myself thinking things like &amp;ldquo;Why is this so inconsistent?&amp;rdquo; or &amp;ldquo;Why is this syntax so complicated?&amp;rdquo;. And it finally occurred to me that I&amp;rsquo;ve been ruined by the way Clojure/ClojureScript/Lisp/Scheme do things.</description>
    </item>
    
    <item>
      <title>Speech Synthesis in ClojureScript</title>
      <link>https://yo-dave.com/2016/07/17/speech-synthesis-in-clojurescript/</link>
      <pubDate>Sun, 17 Jul 2016 12:35:08 +0000</pubDate>
      
      <guid>https://yo-dave.com/2016/07/17/speech-synthesis-in-clojurescript/</guid>
      <description>&lt;p&gt;Just like everyone else, it seems, I&amp;rsquo;ve been following all of the news about voice-activated personal assistants. There are all the commercial offerings like Siri, Alexa, Cortana, and so on, as well as some DIY projects on the web, like this &lt;a href=&#34;https://blog.truthlabs.com/rethinking-voice-search-2496640fdec2#.uvnrkmji0&#34;&gt;one&lt;/a&gt; and &lt;a href=&#34;https://howchoo.com/g/yti5mmq0ntu/add-voice-controls-to-your-raspberry-pi-using-jasper&#34;&gt;this one&lt;/a&gt; and &lt;a href=&#34;http://www.instructables.com/id/Raspberri-Personal-Assistant/&#34;&gt;this one&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;These types of projects typically involve a front end that converts voice to text, some middle piece that interprets the text and obtains some answer or creates an action, ending up with a voice response by the system back to the user. I have some (out-of-date) experience with speech to text, but not the other end of the process: text to speech. So here&amp;rsquo;s a little investigation into how to do it with ClojureScript. Turns out that it is almost trivial these days.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ClojureScript with Reagent and figwheel</title>
      <link>https://yo-dave.com/2016/03/07/clojurescript-with-reagent-and-figwheel/</link>
      <pubDate>Mon, 07 Mar 2016 00:00:00 +0000</pubDate>
      
      <guid>https://yo-dave.com/2016/03/07/clojurescript-with-reagent-and-figwheel/</guid>
      <description>&lt;p&gt;I have a bit of a love/hate relationship with &lt;a href=&#34;https://github.com/clojure/clojurescript&#34;&gt;ClojureScript&lt;/a&gt;. On the one hand, it is a Lisp, with all the power it entails. On the other, the development toolchain can be byzantine. With the advent of &lt;a href=&#34;http://www.2ality.com/2015/06/web-assembly.html&#34;&gt;WebAssembly&lt;/a&gt; and &lt;a href=&#34;https://github.com/lukehoban/es6features/blob/master/README.md&#34;&gt;ECMAScript6&lt;/a&gt;, I have hopes of seeing tail call optimization (allowing true recursion) handled in ClojureScript, if not Clojure itself. And &lt;a href=&#34;https://github.com/reagent-project/reagent&#34;&gt;Reagent&lt;/a&gt; and &lt;a href=&#34;https://github.com/bhauman/lein-figwheel&#34;&gt;figwheel&lt;/a&gt; can make web development (not my strong suite) much easier.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>